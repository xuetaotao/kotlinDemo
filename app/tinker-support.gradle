apply plugin: 'com.tencent.bugly.tinker-support'
apply plugin: 'com.tencent.tinker.patch'

def bakPath = file("${buildDir}/bakApk/")

/**
 * 此处填写每次构建生成的基准包目录
 */
def baseApkDir = "app-0322-16-50-22"

/**
 * 打包路径 注意：生产版本必须指定为空，
 * 打补丁包：用注释行替换 def customBaseApk = ""
 */
def customBaseApk = ""
//def customBaseApk = "${bakPath}/${baseApkDir}/pro/app-pro-release.apk"
//def customBaseApk = "${bakPath}/${baseApkDir}/app-release.apk"

/**
 * 对于插件各参数的详细解析请参考
 * https://bugly.qq.com/docs/utility-tools/plugin-gradle-hotfix/
 */
tinkerSupport {

    // 开启tinker-support插件，默认值true
    enable = true

    //需要打开，官方教程没有
    tinkerEnable = true

    // 指定归档目录，默认值当前module的子目录tinker
    autoBackupApkDir = "${bakPath}"

    // 是否启用覆盖tinkerPatch配置功能，默认值false
    // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch
    //但是对于tinkerPatch中独有的配置项，如allowLoaderInAnyDex貌似覆盖不了，可以在tinkerPatch中配置
    overrideTinkerPatchConfiguration = true

    // 编译补丁包时，必需指定基线版本的apk，默认值为空
    // 如果为空，则表示不是进行补丁包的编译
    // @{link tinkerPatch.oldApk }
    baseApk = "${customBaseApk}"


    // 对应tinker插件applyMapping
    baseApkProguardMapping = "${bakPath}/${baseApkDir}/app-release-mapping.txt"

    // 对应tinker插件applyResourceMapping
    // 可选参数；在编译新的apk时候，我们希望通过旧apk的R.txt文件保持ResId的分配，这样不仅可以减少补丁包的大小，
    // 同时也避免由于ResId改变导致remote view异常
    baseApkResourceMapping = "${bakPath}/${baseApkDir}/app-release-R.txt"

    // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性
//    tinkerId = "base-2.9.8"
    autoGenerateTinkerId = true//	自动生成tinkerId

    // 构建多渠道补丁时使用
    buildAllFlavorsDir = "${bakPath}/${baseApkDir}"

    // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持）
    isProtectedApp = true

    // 是否开启反射Application模式
    enableProxyApplication = false

    // 是否支持新增非export的Activity（注意：设置为true才能修改AndroidManifest文件）
    supportHotplugComponent = true

    //usingResourceMapping默认为false，可以点开看下代码，
    // 对应tinkerPatch.buildConfig.usingResourceMapping(这个是猜的，点开看代码是和TinkerBuildConfigExtension.usingResourceMapping命名相同)
//    usingResourceMapping = true

    //对应tinkerPatch中dex闭包下面的loader配置
//    dexLoader = ["org.xmlpull.v1.XmlPullParser", "org.xmlpull.v1.XmlPullParserException"]
}

/**
 * 一般来说,我们无需对下面的参数做任何的修改
 * 对于各参数的详细介绍请参考:
 * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97
 *
 * 因为tinkerSupport中开启了 overrideTinkerPatchConfiguration = true，会覆盖tinkerPatch配置功能,
 * 开启后tinkerPatch配置不生效，即无需添加tinkerPatch
 */
tinkerPatch {
    //oldApk ="${bakPath}/${appName}/app-release.apk"
    ignoreWarning = false
    useSign = true
    //对于tinkerPatch中独有的配置项，如allowLoaderInAnyDex貌似tinkerSupport覆盖不了，可以在tinkerPatch中配置
    allowLoaderInAnyDex = true
    removeLoaderForAllDex = true
    dex {
        dexMode = "jar"
        pattern = ["classes*.dex"]
        loader = []
    }
    lib {
        pattern = ["lib/*/*.so"]
    }

    res {
        pattern = ["res/*", "r/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]
        ignoreChange = []
        largeModSize = 100
    }

    packageConfig {
    }
    sevenZip {
        zipArtifact = "com.tencent.mm:SevenZip:1.1.10"
//        path = "/usr/local/bin/7za"
    }
    buildConfig {
        keepDexApply = false

        //tinkerId = "1.0.1-base"

        //可选，设置mapping文件，建议保持旧apk的proguard混淆方式
        //applyMapping = "${bakPath}/${appName}/app-release-mapping.txt"

        //指定旧资源 id 映射 (R.txt) 文件以应用ResourceMapping
        //可选，设置R.txt文件，通过旧apk文件保持ResId的分配
        //applyResourceMapping = "${bakPath}/${appName}/app-release-R.txt"

        //usingResourceMapping默认为false，可以点开看下代码，对应tinkerPatch.buildConfig.usingResourceMapping
//        usingResourceMapping = true
    }


}
